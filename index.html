<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galactic Center Compass V7 - AOS Euler Display</title>
    <style>
        /* ... (CSS Same as V6) ... */
         body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: Arial, sans-serif; display: flex; flex-direction: column; height: 100vh; }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-overlay { position: absolute; background: rgba(0, 0, 0, 0.7); padding: 8px; border-radius: 5px; font-size: 11px; line-height: 1.4; z-index: 10; max-width: 90%; box-sizing: border-box; }
        #info { bottom: 10px; left: 10px; max-width: 180px; }
        #celestial-info { top: 40px; right: 10px; text-align: right;}
        #sensor-stats { top: 40px; left: 10px; display: none; }
        #calibration { bottom: 10px; right: 10px; max-width: 200px; }
        #overrides { position: absolute; top: 150px; right: 10px; max-width: 200px; }
        #overrides label, #overrides input { display: block; margin-bottom: 3px; width: 95%; }
        #overrides input[type="number"] { background: #333; color: #fff; border: 1px solid #555; padding: 2px; font-size: 10px; max-width: 100px; }
        #overrides button { margin-top: 5px; padding: 3px 6px; font-size: 10px; }
        #overrides fieldset { border: 1px solid #777; padding: 5px; margin-top: 5px; }
        #calibration button { margin-top: 3px; margin-right: 3px; padding: 3px 6px; font-size: 10px; }
        #permissions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; background: rgba(50, 50, 50, 0.9); padding: 20px; border-radius: 10px; text-align: center; display: none; }
        #permissions button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        #status { position: absolute; top: 10px; left: 10px; background: rgba(255, 100, 0, 0.8); padding: 5px 8px; border-radius: 3px; font-size: 11px; z-index: 10; display: none; max-width: 80%; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="status" class="ui-overlay"></div>
    <div id="info" class="ui-overlay">
        <b>Device Info</b><br>
        Location: <span id="loc">Waiting...</span><br>
        Mode: <span id="mode">PC (Default)</span><br>
        Alignment: <span id="alignment-status">Inactive</span>
    </div>
     <div id="celestial-info" class="ui-overlay">
         <b>Target Positions (World)</b><br>
         Galactic Ctr Az: <span id="gc-az">Calc...</span>°<br>
         Galactic Ctr Alt: <span id="gc-alt">Calc...</span>°<br>
         Sun Az: <span id="sun-az">Calc...</span>°<br>
         Sun Alt: <span id="sun-alt">Calc...</span>°
     </div>
    <div id="sensor-stats" class="ui-overlay">
        <b>Sensor Data (Raw)</b><br> Absolute: <span id="sensor-abs">---</span><br>
        Alpha (Z): <span id="sensor-a">---</span>°<br>
        Beta (X): <span id="sensor-b">---</span>°<br>
        Gamma (Y): <span id="sensor-g">---</span>°<br>
    </div>
     <div id="calibration" class="ui-overlay">
         <b>Manual Alignment</b><br>
         <button id="align-north-button">Align Top to North</button>
         <button id="align-sun-button">Align Top to Sun</button>
         <button id="reset-alignment-button" disabled>Reset Align</button>
     </div>
    <div id="overrides" class="ui-overlay">
        <label><input type="checkbox" id="enable-overrides"> Enable Overrides</label>
        <fieldset id="override-inputs" disabled>
             <legend>Manual Values</legend>
             <label>Lat: <input type="number" id="override-lat" step="0.01"></label>
             <label>Lon: <input type="number" id="override-lon" step="0.01"></label>
             <label>Alpha: <input type="number" id="override-a" step="1"></label>
             <label>Beta: <input type="number" id="override-b" step="1"></label>
             <label>Gamma: <input type="number" id="override-g" step="1"></label>
             <button id="apply-overrides">Apply Overrides</button>
        </fieldset>
    </div>
    <div id="permissions">
        <p>Allow access to sensors and location for accurate pointing.</p>
        <button id="permissionButton">Grant Permissions</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Global Variables (Same as V6) ---
        let scene, camera, renderer, needleGroup, starPoints; let userLocation = null; const fallbackLocation = { latitude: 50.93, longitude: 3.33 }; let galacticCenterAzAlt = { azimuth: 0, altitude: 0 }; let sunAzAlt = { azimuth: 0, altitude: 0 }; let latestDeviceOrientation = new THREE.Quaternion(); let hasDeviceOrientationData = false; let locationPermissionGranted = false; let locationTimeout = null; let overridesEnabled = false; let orientationSensor = null; let manualNorthOffset = new THREE.Quaternion().identity(); let isAlignmentActive = false; const needleLocalPointingAxis = new THREE.Vector3(0, 0, 1); const starCount = 15000; const starRadius = 400; const DEG_TO_RAD = Math.PI / 180; const RAD_TO_DEG = 180 / Math.PI;

        // --- DOM Elements (Same as V6) ---
        const locElement = document.getElementById('loc'); const gcAzElement = document.getElementById('gc-az'); const gcAltElement = document.getElementById('gc-alt'); const sunAzElement = document.getElementById('sun-az'); const sunAltElement = document.getElementById('sun-alt'); const modeElement = document.getElementById('mode'); const alignmentStatusElement = document.getElementById('alignment-status'); const sensorStatsDiv = document.getElementById('sensor-stats'); const sensorAbsElement = document.getElementById('sensor-abs'); const sensorAElement = document.getElementById('sensor-a'); const sensorBElement = document.getElementById('sensor-b'); const sensorGElement = document.getElementById('sensor-g'); const overrideCheckbox = document.getElementById('enable-overrides'); const overrideInputsFieldset = document.getElementById('override-inputs'); const overrideLatInput = document.getElementById('override-lat'); const overrideLonInput = document.getElementById('override-lon'); const overrideAInput = document.getElementById('override-a'); const overrideBInput = document.getElementById('override-b'); const overrideGInput = document.getElementById('override-g'); const applyOverridesButton = document.getElementById('apply-overrides'); const permissionsDiv = document.getElementById('permissions'); const permissionButton = document.getElementById('permissionButton'); const statusElement = document.getElementById('status'); const alignNorthButton = document.getElementById('align-north-button'); const alignSunButton = document.getElementById('align-sun-button'); const resetAlignmentButton = document.getElementById('reset-alignment-button');

        // Constants (GC coords)
        const GC_RA_DEG = (17 + 45/60 + 40/3600) * 15; const GC_DEC_DEG = -(29 + 0/60 + 28/3600);

        // --- Initialization (Same as V6) ---
        function init() { /* ... Same setup for scene, camera, renderer, lights, stars, needle ... */ scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 0.3, 3.5); camera.lookAt(0, 0, 0); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); document.getElementById('container').appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0x505050); scene.add(ambientLight); const pointLight = new THREE.PointLight(0xffffff, 0.8); camera.add(pointLight); scene.add(camera); const positions = new Float32Array(starCount * 3); const colors = new Float32Array(starCount * 3); const starGeometry = new THREE.BufferGeometry(); const baseColor = new THREE.Color(); for (let i = 0; i < starCount; i++) { const i3 = i * 3; const vector = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1); vector.normalize().multiplyScalar(starRadius); positions[i3 + 0] = vector.x; positions[i3 + 1] = vector.y; positions[i3 + 2] = vector.z; const intensity = Math.random() * 0.6 + 0.4; baseColor.setRGB(intensity, intensity, intensity); colors[i3 + 0] = baseColor.r; colors[i3 + 1] = baseColor.g; colors[i3 + 2] = baseColor.b; } starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); const starMaterial = new THREE.PointsMaterial({ size: 1.2, sizeAttenuation: true, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending }); starPoints = new THREE.Points(starGeometry, starMaterial); scene.add(starPoints); needleGroup = new THREE.Group(); const arrowColor = 0x00ff00; const arrowMaterial = new THREE.MeshPhongMaterial({ color: arrowColor, emissive: 0x005500 }); const cylinderHeight = 1.5, cylinderRadius = 0.04; const cylinderGeometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 16); const cylinder = new THREE.Mesh(cylinderGeometry, arrowMaterial); cylinder.rotation.x = Math.PI / 2; cylinder.position.z = cylinderHeight / 2; const coneHeight = 0.4, coneRadius = 0.15; const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16); const cone = new THREE.Mesh(coneGeometry, arrowMaterial); cone.rotation.x = Math.PI / 2; cone.position.z = cylinderHeight + coneHeight / 2; needleGroup.add(cylinder); needleGroup.add(cone); scene.add(needleGroup); window.addEventListener('resize', onWindowResize, false); overrideCheckbox.addEventListener('change', handleOverrideToggle); applyOverridesButton.addEventListener('click', applyOverrides); alignNorthButton.addEventListener('click', () => setManualAlignment('North')); alignSunButton.addEventListener('click', () => setManualAlignment('Sun')); resetAlignmentButton.addEventListener('click', resetManualAlignment); setupOrientationSensor(); checkLocationPermission(); animate(); }

        // --- Sensor Setup (Same as V6) ---
        function setupOrientationSensor() { /* ... Same as V6 ... */ if ('AbsoluteOrientationSensor' in window) { Promise.all([ navigator.permissions.query({ name: "accelerometer" }), navigator.permissions.query({ name: "gyroscope" }), navigator.permissions.query({ name: "magnetometer" }) ]).then((results) => { if (results.every((result) => result.state === "granted")) { try { orientationSensor = new AbsoluteOrientationSensor({ frequency: 60 }); orientationSensor.addEventListener('reading', handleAOSReading); orientationSensor.addEventListener('error', handleAOSError); orientationSensor.start(); hasDeviceOrientationData = true; updateModeDisplay('Mobile (AOS)'); showStatus("Using AbsoluteOrientationSensor.", true); sensorStatsDiv.style.display = 'block'; } catch (error) { console.error("AbsoluteOrientationSensor error:", error); handleAOSError(error); } } else { console.log("Required sensor permissions not granted for AbsoluteOrientationSensor."); fallbackToDeviceOrientation(); } }).catch(error => { console.error("Permission query error:", error); fallbackToDeviceOrientation(); }); } else { console.log("AbsoluteOrientationSensor not supported."); fallbackToDeviceOrientation(); } }
        function fallbackToDeviceOrientation() { /* ... Same as V6 ... */ orientationSensor = null; if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { console.log("Waiting for DeviceOrientationEvent permission via button."); window.addEventListener('deviceorientation', handleDOEReading); } else if (typeof DeviceOrientationEvent !== 'undefined'){ window.addEventListener('deviceorientation', handleDOEReading); console.log("Using DeviceOrientationEvent."); } else { showStatus("No orientation sensors supported."); updateModeDisplay('PC (No Sensors)'); } }
        function handleAOSError(event) { /* ... Same as V6 ... */ console.error('AbsoluteOrientationSensor Error:', event.error); if (orientationSensor) { orientationSensor.stop(); orientationSensor = null; } showStatus("AbsoluteOrientationSensor failed, falling back.", true); fallbackToDeviceOrientation(); }
        // --- Permissions & Location (Same as V6) ---
        function checkAndRequestPermissions() { /* ... Same as V6 ... */ if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { permissionsDiv.style.display = 'block'; permissionButton.onclick = requestOrientationPermission; checkLocationPermission(); } else { if (typeof DeviceOrientationEvent !== 'undefined') { window.addEventListener('deviceorientation', handleDOEReading); console.log("Orientation listener added directly."); } else { showStatus("Orientation sensors not supported."); updateModeDisplay('PC (No Sensors)'); } checkLocationPermission(); } }
        function requestOrientationPermission() { /* ... Same as V6 ... */ DeviceOrientationEvent.requestPermission().then(permissionState => { permissionsDiv.style.display = 'none'; if (permissionState === 'granted') { window.addEventListener('deviceorientation', handleDOEReading); showStatus("Orientation sensor access granted.", true); } else { showStatus("Orientation sensor permission denied."); updateModeDisplay('PC (Denied Sensors)'); } }).catch(error => { console.error("Orientation permission error:", error); showStatus("Error requesting orientation permissions."); permissionsDiv.style.display = 'none'; updateModeDisplay('PC (Sensor Error)'); }); }
        function checkLocationPermission() { /* ... Same as V6 ... */ if ('geolocation' in navigator) { clearTimeout(locationTimeout); locationTimeout = setTimeout(useFallbackLocation, 8000); navigator.geolocation.getCurrentPosition(handleLocationSuccess, handleLocationError, { enableHighAccuracy: true, timeout: 7000, maximumAge: 60000 }); } else { showStatus("Geolocation not supported."); useFallbackLocation(); } }
        function useFallbackLocation() { /* ... Same as V6 ... */ clearTimeout(locationTimeout); if (!userLocation) { userLocation = fallbackLocation; locElement.textContent = `Approx. ${userLocation.latitude.toFixed(2)}, ${userLocation.longitude.toFixed(2)} (Fallback)`; locationPermissionGranted = true; showStatus("Using approximate location for Oostrozebeke, BE.", true); calculateCelestialPositions(); populateOverrideInputs(); } }
        function handleLocationSuccess(position) { /* ... Same as V6 ... */ clearTimeout(locationTimeout); userLocation = { latitude: position.coords.latitude, longitude: position.coords.longitude }; locElement.textContent = `${userLocation.latitude.toFixed(4)}, ${userLocation.longitude.toFixed(4)}`; locationPermissionGranted = true; clearStatus(); calculateCelestialPositions(); populateOverrideInputs(); }
        function handleLocationError(error) { /* ... Same as V6 ... */ console.warn("Geolocation error:", error.message); useFallbackLocation(); }

        // --- Sensor Reading Handlers ---
        function handleAOSReading() {
            if (overridesEnabled || !orientationSensor || !orientationSensor.quaternion) return;

            // 1. Get RAW orientation from sensor
            const rawOrientation = new THREE.Quaternion().fromArray(orientationSensor.quaternion);

            // --- MODIFICATION START ---
            // 2. Display Euler angles derived from RAW orientation
            const euler = new THREE.Euler();
            // Use the same order ('ZXY') for consistency with DOE display interpretation
            // NOTE: Euler conversion from Quaternion can have ambiguities (Gimbal Lock)
            // but provides a familiar Alpha/Beta/Gamma representation.
            euler
