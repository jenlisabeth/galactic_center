<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galactic Center Compass V2</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: calc(100% - 40px);
            z-index: 10;
        }
        #permissions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            background: rgba(50, 50, 50, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none; /* Initially hidden */
        }
        #permissions button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #status {
             position: absolute;
             top: 10px;
             left: 10px;
             background: rgba(255, 0, 0, 0.7);
             padding: 5px;
             border-radius: 3px;
             font-size: 10px;
             z-index: 10;
             display: none; /* Hidden initially */
         }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        Galactic Center (Sgr A*):<br>
        RA: 17h 45m 40s<br>
        Dec: -29Â° 00' 28"<br>
        Distance: ~25,800 light-years<br>
        Sun's Orbital Speed: ~230 km/s<br>
        --------------------<br>
        Your Location: <span id="loc">Waiting...</span><br>
        GC Azimuth (World): <span id="az">Calculating...</span><br>
        GC Altitude (World): <span id="alt">Calculating...</span><br>
        </div>
    <div id="permissions">
        <p>This application needs access to your device's orientation sensors and location to point towards the Galactic Center.</p>
        <button id="permissionButton">Grant Permissions</button>
    </div>
    <div id="status"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, needle;
        let userLocation = null;
        let galacticCenterAzAlt = { azimuth: 0, altitude: 0 };
        let latestDeviceOrientation = new THREE.Quaternion(); // Stores the device orientation
        let hasOrientationPermission = false;
        let hasLocationPermission = false;

        const infoElement = document.getElementById('info');
        const locElement = document.getElementById('loc');
        const azElement = document.getElementById('az');
        const altElement = document.getElementById('alt');
        const permissionsDiv = document.getElementById('permissions');
        const permissionButton = document.getElementById('permissionButton');
        const statusElement = document.getElementById('status');

        // Galactic Center Coordinates (J2000.0)
        const GC_RA_DEG = (17 + 45/60 + 40/3600) * 15; // Approx 266.4167 degrees
        const GC_DEC_DEG = -(29 + 0/60 + 28/3600);    // Approx -29.0078 degrees
        const GC_RA_RAD = GC_RA_DEG * Math.PI / 180;
        const GC_DEC_RAD = GC_DEC_DEG * Math.PI / 180;

        // Define the needle's local axis that points forward (matches ConeGeometry's default)
        const needleLocalPointingAxis = new THREE.Vector3(0, 0, 1); // Cone points along +Z by default

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            // Add faint background grid/stars for orientation reference? Optional.
            // const gridHelper = new THREE.GridHelper( 100, 10 );
            // scene.add( gridHelper );

            // Camera - FIXED POSITION
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Position camera slightly above and back, looking at origin
            camera.position.set(0, 1, 5); // Adjust Z for distance, Y for slight overhead view
            camera.lookAt(0, 0, 0); // Look at the center where the needle will be

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            camera.add(pointLight); // Attach light to camera so needle is always lit
            scene.add(camera); // Add camera to scene (required for camera-attached light)

            // Compass Needle Model (Cone pointing along +Z)
            const geometry = new THREE.ConeGeometry(0.3, 1.5, 16); // radius, height, segments
            // Make the base of the cone the 'pointer' end
            geometry.translate(0, -0.75, 0); // Move center down
            geometry.rotateX(Math.PI); // Point tip towards +Z
            const material = new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0x551111, side: THREE.DoubleSide });
            needle = new THREE.Mesh(geometry, material);
            needle.position.set(0, 0, 0); // Position needle at the origin
            scene.add(needle);


            // Handle Resizing
            window.addEventListener('resize', onWindowResize, false);

            // Start animation loop
            animate();

            // Check for permissions and request if needed
            checkAndRequestPermissions();
        }

        // --- Permissions Handling ---
         function checkAndRequestPermissions() {
             if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                 // iOS 13+ needs explicit permission
                 permissionsDiv.style.display = 'block'; // Show button first
                 permissionButton.onclick = () => {
                     DeviceOrientationEvent.requestPermission()
                         .then(permissionState => {
                             if (permissionState === 'granted') {
                                 window.addEventListener('deviceorientation', handleOrientation);
                                 hasOrientationPermission = true;
                                 checkLocationPermission(); // Proceed to location
                             } else {
                                 showStatus("Orientation sensor permission denied.");
                             }
                             permissionsDiv.style.display = 'none'; // Hide after attempt
                         })
                         .catch(error => {
                              console.error("DeviceOrientationEvent permission error:", error);
                              showStatus("Error requesting orientation permissions.");
                              permissionsDiv.style.display = 'none';
                         });
                 };
             } else if (typeof DeviceOrientationEvent !== 'undefined'){
                 // Assume permission is granted or not needed (older browsers/Android)
                 console.log("DeviceOrientationEvent found, adding listener.");
                 window.addEventListener('deviceorientation', handleOrientation);
                 hasOrientationPermission = true;
                 checkLocationPermission(); // Proceed to location
             } else {
                  showStatus("Device orientation sensors not supported by this browser.");
                  permissionsDiv.style.display = 'block';
                  permissionButton.style.display = 'none';
                  document.querySelector('#permissions p').textContent = "Device orientation sensors are not supported. Compass cannot function.";
             }
         }

         function checkLocationPermission() {
             if ('geolocation' in navigator) {
                 navigator.geolocation.getCurrentPosition(
                     handleLocationSuccess,
                     handleLocationError,
                     { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 } // Force fresh reading
                 );
             } else {
                 showStatus("Geolocation is not supported by this browser.");
                 locElement.textContent = "Not Supported";
                 updateGalacticCenterPosition(); // Calculate with default Lat/Lon 0,0
             }
         }

        function handleLocationSuccess(position) {
            userLocation = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude
            };
            locElement.textContent = `${userLocation.latitude.toFixed(4)}, ${userLocation.longitude.toFixed(4)}`;
            clearStatus();
            hasLocationPermission = true;
            updateGalacticCenterPosition(); // Recalculate Az/Alt
        }

        function handleLocationError(error) {
            console.error("Geolocation error:", error);
            hasLocationPermission = false;
            let message = "Location unavailable";
            // ... (error messages as before) ...
             switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = "Location permission denied.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    message = "Location request timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    message = "An unknown location error occurred.";
                    break;
            }
             showStatus(message);
             locElement.textContent = "Error";
             updateGalacticCenterPosition(); // Attempt calculation with default 0,0 location
        }

        // --- Sensor Handling ---
        function handleOrientation(event) {
             if (!event.absolute) {
                 showStatus("Using relative orientation. Pointing may be inaccurate until device stabilizes or is calibrated.", true);
             } else {
                 clearStatus(); // Clear if it was showing relative orientation message
             }

            if (event.alpha === null || event.beta === null || event.gamma === null) {
                 // Don't update if data is missing
                 showStatus("Incomplete orientation data.", true);
                 return;
            }

            // Convert device orientation angles (degrees) to quaternion
            const alphaRad = event.alpha * Math.PI / 180; // Z axis rotation (compass heading)
            const betaRad = event.beta * Math.PI / 180;   // X axis rotation (pitch)
            const gammaRad = event.gamma * Math.PI / 180; // Y axis rotation (roll)

            // Create Euler angle representation in 'ZXY' order (common for device orientation)
            const euler = new THREE.Euler(betaRad, alphaRad, -gammaRad, 'YXZ'); // Changed order to YXZ as ZXY wasn't quite right. Experimentation needed. Might be device dependent. Also negated gamma.

            latestDeviceOrientation.setFromEuler(euler);

            // **** CRITICAL: DO NOT ROTATE THE CAMERA ****
            // camera.quaternion.copy(latestDeviceOrientation); // <-- REMOVED
        }


        // --- Astronomical Calculations ---
        function updateGalacticCenterPosition() {
            // Only calculate if we have location, otherwise values are meaningless
            // if (!hasLocationPermission) return; // Or calculate using 0,0 as default? Let's use 0,0 for now.

            const now = new Date();
            const lat = userLocation ? userLocation.latitude : 0;
            const lon = userLocation ? userLocation.longitude : 0;

            // ... (JD, GMST, LST, HA calculations remain the same as before) ...
            // 1. Calculate Julian Date (JD)
            const year = now.getUTCFullYear();
            const month = now.getUTCMonth() + 1; // 0-indexed
            const day = now.getUTCDate();
            const hour = now.getUTCHours();
            const minute = now.getUTCMinutes();
            const second = now.getUTCSeconds();
            const dayFraction = (hour + minute / 60 + second / 3600) / 24;
            let Y = year, M = month;
            if (M <= 2) { Y -= 1; M += 12; }
            const A = Math.floor(Y / 100);
            const B = 2 - A + Math.floor(A / 4);
            const JD = Math.floor(365.25 * (Y + 4716)) + Math.floor(30.6001 * (M + 1)) + day + dayFraction + B - 1524.5;

            // 2. Calculate Greenwich Mean Sidereal Time (GMST) in hours
            const d = JD - 2451545.0; // Days since J2000.0
            const T = d / 36525.0; // Julian centuries since J2000.0
            let GMST_hours = (18.697374558 + 24.06570982441908 * d) % 24; // Simplified GMST approx from Meeus
             GMST_hours = (GMST_hours + (hour + minute/60 + second/3600) * 1.002737909) % 24; // Add UT correction
             if (GMST_hours < 0) GMST_hours += 24;

            // 3. Calculate Local Sidereal Time (LST) in degrees
            const LST_hours = (GMST_hours + lon / 15); // lon is degrees east (+), west (-)
            const LST_deg = (LST_hours * 15) % 360;
             if (LST_deg < 0) LST_deg += 360;
            const LST_rad = LST_deg * Math.PI / 180;

            // 4. Calculate Hour Angle (HA)
            let HA_deg = (LST_deg - GC_RA_DEG);
             if (HA_deg < -180) HA_deg += 360;
             if (HA_deg > 180) HA_deg -= 360;
            const HA_rad = HA_deg * Math.PI / 180;

            // 5. Convert RA/Dec to Azimuth/Altitude
            const latRad = lat * Math.PI / 180;
            const sinAlt = Math.sin(GC_DEC_RAD) * Math.sin(latRad) + Math.cos(GC_DEC_RAD) * Math.cos(latRad) * Math.cos(HA_rad);
            const altRad = Math.asin(sinAlt);
            const cosAlt = Math.cos(altRad);
            let azRad = 0;
             if (Math.abs(cosAlt) > 0.0001) { // Avoid division by zero near zenith
                let cosAz = (Math.sin(GC_DEC_RAD) - sinAlt * Math.sin(latRad)) / (cosAlt * Math.cos(latRad));
                cosAz = Math.max(-1, Math.min(1, cosAz));
                let sinAz = (-Math.cos(GC_DEC_RAD) * Math.sin(HA_rad)) / cosAlt;
                sinAz = Math.max(-1, Math.min(1, sinAz));
                azRad = Math.atan2(sinAz, cosAz); // Azimuth East of North, -PI to PI
            } else {
                 // At zenith, azimuth is undefined; use LST perhaps? Or 0.
                 azRad = 0; // Default to North if exactly at zenith
             }
            if (azRad < 0) {
                azRad += 2 * Math.PI; // Convert to 0 to 2PI range
            }

            galacticCenterAzAlt.azimuth = azRad * 180 / Math.PI; // Store in degrees
            galacticCenterAzAlt.altitude = altRad * 180 / Math.PI; // Store in degrees

            // Update display
            azElement.textContent = galacticCenterAzAlt.azimuth.toFixed(2) + 'Â°';
            altElement.textContent = galacticCenterAzAlt.altitude.toFixed(2) + 'Â°';

            // Note: Needle direction update happens in animate() using these values
        }


         // --- Update Needle Direction (Called from Animate) ---
         function updateNeedleRotation() {
             if (!needle || !hasOrientationPermission) return; // Don't rotate if no permission or needle missing

             // 1. Get Target Vector in World Frame (Y-Up, Z-North, X-East)
             const azRad = galacticCenterAzAlt.azimuth * Math.PI / 180;
             const altRad = galacticCenterAzAlt.altitude * Math.PI / 180;

             const targetVectorWorld = new THREE.Vector3();
             targetVectorWorld.set(
                 Math.cos(altRad) * Math.sin(azRad), // X (East)
                 Math.sin(altRad),                   // Y (Up)
                 Math.cos(altRad) * Math.cos(azRad)  // Z (North)
             ).normalize();

             // 2. Get Inverse Device Orientation (World -> Device)
             // We use conjugate() which is equivalent to inverse() for normalized quaternions
             const inverseDeviceOrientation = latestDeviceOrientation.clone().conjugate();

             // 3. Transform World Target Vector into Device's Coordinate Frame
             const targetVectorDevice = targetVectorWorld.clone().applyQuaternion(inverseDeviceOrientation);

             // 4. Calculate the rotation needed to align the needle's local pointing axis
             //    (needleLocalPointingAxis) with the target vector in the device's frame.
             const finalNeedleRotation = new THREE.Quaternion();
             finalNeedleRotation.setFromUnitVectors(needleLocalPointingAxis, targetVectorDevice.normalize());

             // 5. Apply the calculated rotation to the needle
             needle.quaternion.slerp(finalNeedleRotation, 0.2); // Use slerp for smoother rotation
             // needle.quaternion.copy(finalNeedleRotation); // Use copy for immediate rotation

         }


        // --- Animation Loop ---
        let lastCalcTime = 0;
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();

            // Update astronomical calculations periodically (e.g., every 2 seconds)
            if (now - lastCalcTime > 2000) { // Update less frequently
                 if (hasLocationPermission) { // Only calc if we have location permission
                     updateGalacticCenterPosition();
                 } else if (!userLocation) {
                     // If still waiting for initial location attempt, maybe try again
                     checkLocationPermission();
                 }
                 lastCalcTime = now;
             }

            // Update needle rotation based on latest sensor data and calculated position
            updateNeedleRotation();

            // Renderer
            renderer.render(scene, camera);
        }

        // --- Utility Functions ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let statusTimeout;
        function showStatus(message, temporary = false) {
            statusElement.textContent = message;
            statusElement.style.display = 'block';
            if (statusTimeout) clearTimeout(statusTimeout);
            if (temporary) {
                 statusTimeout = setTimeout(clearStatus, 4000); // Hide after 4 seconds
             }
        }

        function clearStatus() {
            if (statusElement.style.display !== 'none') {
                 // Only hide if it wasn't replaced by a non-temporary message
                 if (!statusTimeout || statusElement.textContent === "") { // Basic check
                    statusElement.style.display = 'none';
                 }
            }
            statusTimeout = null;
        }

        // --- Start ---
        init();

    </script>
</body>
</html>
