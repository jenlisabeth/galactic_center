<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Milky-Way Galactic-Centre Compass</title>
<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#000;color:#0f0;font-family:monospace}
  #hud{position:fixed;top:0;left:0;padding:8px 12px;background:rgba(0,0,0,.6);line-height:1.4;font-size:.85rem;white-space:pre}
  #gate{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
        background:#000;color:#fff;font-family:sans-serif;flex-direction:column;gap:.8rem}
  #gate button{padding:.6rem 1.2rem;font-size:1rem}
  canvas{display:block}
</style>
</head>
<body>

<div id="hud" hidden>initialising…</div>

<!-- permission / start overlay -->
<div id="gate">
  <div>This demo needs access to:</div>
  <ul style="margin:0 0 .6rem 1.2rem;text-align:left">
    <li>Motion/orientation sensors (gyroscope + accelerometer)</li>
    <li>Location (for latitude & longitude)</li>
    <li>(Optionally) Magnetometer</li>
  </ul>
  <button id="btnStart">Grant permissions & start</button>
  <div id="err" style="color:#f66"></div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.133.0/build/three.module.js?module";
import {DeviceOrientationControls} from "https://unpkg.com/three@0.133.0/examples/jsm/controls/DeviceOrientationControls.js?module";

/* === constants ========================================================= */
const GAL_CTR = { ra: THREE.MathUtils.degToRad(266.41683),   // 17h45m40.04s
                  dec:THREE.MathUtils.degToRad(-29.00781) }; // −29°00′28.1″
const DIST_PC=8300,  DIST_LY=DIST_PC*3.262,
      DIST_KM=DIST_PC*3.086e13,  SUN_V=220;

/* === DOM =============================================================== */
const hud=document.getElementById("hud"),
      gate=document.getElementById("gate"),
      btn=document.getElementById("btnStart"),
      errLabel=document.getElementById("err");

/* === three.js boilerplate ============================================= */
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1e4);
camera.position.set(0,0,4);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const controls=new DeviceOrientationControls(camera);

/* background stars */
scene.background=new THREE.Color(0x000000);
scene.add(new THREE.Points(
  new THREE.BufferGeometry().setAttribute('position',
    new THREE.Float32BufferAttribute(
      Array.from({length:2000},()=>THREE.MathUtils.randFloatSpread(600)),3)),
  new THREE.PointsMaterial({size:1,color:0xffffff})
));

/* cursor */
const group=new THREE.Group(); scene.add(group);
const size=1.4, mat=new THREE.MeshBasicMaterial({color:0x0f0,wireframe:true});
const square=new THREE.Mesh(new THREE.BoxGeometry(size,size*0.02,size),mat);
square.position.z=-size*0.5; group.add(square);
const cone=new THREE.Mesh(new THREE.ConeGeometry(size*0.12,size*0.25,4),mat);
cone.position.z=-size; cone.rotation.x=Math.PI; group.add(cone);

/* === utilities ========================================================= */
let lat=null,lng=null;          // updated by geolocation

const toRad = d=>d*Math.PI/180;
function lstMillis(ms,lon){
  const d=(ms/86400000)+2440587.5-2451545.0;
  return (280.46061837+360.98564736629*d+lon)%360;
}
function radecToAzAlt(ra,dec,φ,λ,t){
  const ha=toRad(lstMillis(t,λ))-ra,
        sinAlt=Math.sin(dec)*Math.sin(φ)+Math.cos(dec)*Math.cos(φ)*Math.cos(ha),
        alt=Math.asin(sinAlt),
        cosAz=(Math.sin(dec)-Math.sin(alt)*Math.sin(φ))/(Math.cos(alt)*Math.cos(φ));
  let az=Math.acos(Math.min(Math.max(cosAz,-1),1));
  if(Math.sin(ha)>0) az=2*Math.PI-az;
  return {az,alt};
}
function azAltToVec({az,alt}){
  return new THREE.Vector3(
    Math.cos(alt)*Math.sin(az),
    Math.cos(alt)*Math.cos(az),
    Math.sin(alt)).normalize();
}
function updateHUD(){
  const lst=lstMillis(Date.now(),lng??0);
  hud.textContent=
`lat  : ${lat!=null?lat.toFixed(4)+"°":"n/a"}
lon  : ${lng!=null?lng.toFixed(4)+"°":"n/a"}
LST  : ${lst.toFixed(3)}° (${(lst/15).toFixed(3)} h)

Distance
   km : ${(DIST_KM/1e12).toFixed(3)} ×10¹²
    ly: ${DIST_LY.toFixed(0)}
    pc: ${DIST_PC}

Sun’s orbit speed
   ${SUN_V} km/s`;
}

/* === permission helpers =============================================== */
async function requestMotionPerm() {
  /* iOS 13 + Safari & now also supported by Chromium 124 + */
  async function ask(cls){
    if (cls && typeof cls.requestPermission==="function")
      return (await cls.requestPermission())==="granted";
    return true;
  }
  const okOrient = await ask(window.DeviceOrientationEvent);
  const okMotion = await ask(window.DeviceMotionEvent);
  if(!okOrient && !okMotion) throw new Error("Motion/orientation permission denied.");
}

function requestGeoPerm(){
  return new Promise(res=>{
    const opts={enableHighAccuracy:true,maximumAge:1e4,timeout:10_000};
    navigator.geolocation.getCurrentPosition(p=>{
      lat=p.coords.latitude; lng=p.coords.longitude; res(true);
      /* keep updating */
      navigator.geolocation.watchPosition(pos=>{
        lat=pos.coords.latitude; lng=pos.coords.longitude;
      },console.error,opts);
    },()=>res(false),opts);
  });
}

/* === sensor start ====================================================== */
async function initSensors(){
  await requestMotionPerm();      // throws if denied
  controls.connect();

  /* geolocation: proceed even if user says “No” */
  await requestGeoPerm();
  try{            // optional magnetometer for nicer heading stability
    const mag=new Magnetometer({frequency:60});
    mag.start();
  }catch{}
}

/* === main loop ========================================================= */
function animate(){
  requestAnimationFrame(animate);

  const t=Date.now();
  const φ=lat!=null?toRad(lat):0,  λ=lng!=null?toRad(lng):0;
  const target=azAltToVec(radecToAzAlt(GAL_CTR.ra,GAL_CTR.dec,φ,λ,t));
  group.lookAt(target);
  group.rotation.z+=Math.PI;

  controls.update();
  renderer.render(scene,camera);
  updateHUD();
}

/* === UI ================================================================ */
btn.addEventListener("click", async ()=>{
  errLabel.textContent="";
  try{
    await initSensors();     // wait only for motion/orientation; geo may fail
    gate.hidden=true; hud.hidden=false;
    animate();
  }catch(e){
    errLabel.textContent=e.message;
  }
});

/* desktop convenience: start immediately if motion sensors aren’t needed */
if(!(/Mobi|Android|iPhone|iPad/i).test(navigator.userAgent)){
  btn.click();
}

/* handle resize */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
